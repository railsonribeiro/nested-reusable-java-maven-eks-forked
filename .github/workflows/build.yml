name: Build Workflow

on:
  workflow_call:
    inputs:
      #variables
      app_name:
        required: true
        type: string
      dockerhub_username:
        required: false
        type: string
        default: "postechf57"
      java_version:
        description: "Vers√£o do Java (ex: '17' ou '21')"
        required: false
        type: string
        default: "21"
      #runsteps
      run_validation_and_lint:
        description: "Executar valida√ß√£o e linting"
        required: false
        type: boolean
        default: true
      run_build_and_test:
        description: "Executar build e testes"
        required: false
        type: boolean
        default: true
      run_gates:
        description: "Executar gates de qualidade"
        required: false
        type: boolean
      run_docker_build_and_push:
        required: false
        type: boolean
        default: true
      run_update_deployment:
        description: "Atualizar tag no deployment.yaml e fazer commit"
        required: false
        type: boolean
        default: true
      deployment_path:
        description: "Caminho do deployment.yaml (ex: k8s/prd/deployment.yaml)"
        required: false
        type: string
        default: "k8s/prd/deployment.yaml"
      run_cd:
        description: "Disparar workflow de CD ap√≥s update do deployment"
        required: false
        type: boolean
        default: true
    outputs:
      new_image_pushed:
        description: "Se nova imagem foi publicada"
        value: ${{ jobs.docker-build-and-push.outputs.new_image_pushed }}
      image_tag:
        description: "Tag da imagem publicada"
        value: ${{ jobs.docker-build-and-push.outputs.image_tag }}

jobs:
  validation-and-lint:
    name: Validation & Code Quality
    runs-on: ubuntu-latest
    if: inputs.run_validation_and_lint
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Lint Dockerfile
        run: |
          echo "üîç Verificando qualidade do Dockerfile..."
          
           # Verificar se o Dockerfile existe
           if [ ! -f "Dockerfile" ]; then
             echo "‚ùå ERRO: Dockerfile n√£o encontrado no reposit√≥rio"
             exit 1
           fi
          
           echo "‚úÖ Dockerfile encontrado"
          
           # Instalar hadolint se n√£o estiver dispon√≠vel
           if ! command -v hadolint &> /dev/null; then
             echo "üì¶ Instalando hadolint..."
             wget -O hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
             chmod +x hadolint
             sudo mv hadolint /usr/local/bin/
           fi
          
           echo "üîç Executando lint no Dockerfile..."
           hadolint Dockerfile 

  build_and_test:
    name: Build & Test
#    needs: validation-and-lint
    if: ${{ inputs.run_build_and_test }}
    runs-on: ubuntu-latest
    outputs:
      build_ok: ${{ steps.build_and_test_step.outcome }}
      app_version: ${{ steps.extract_version.outputs.version }}
      image_tag: ${{ steps.extract_version.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ inputs.java_version }}
          cache: maven

      - name: Extract Version from pom.xml
        id: extract_version
        run: |
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$VERSION" >> $GITHUB_OUTPUT
          
          echo "üì¶ Vers√£o do pom.xml: $VERSION"
          echo "üè∑Ô∏è  Tag da imagem: $VERSION"

      - name: Build with Maven
        run: | 
          mvn -B clean verify
          echo "Verificando JaCoCo: target/site/jacoco/jacoco.xml"
          if [ -f "target/site/jacoco/jacoco.xml" ]; then
            echo "::notice::Arquivo encontrado"
            ls -la target/site/jacoco/jacoco.xml
            head -n 20 target/site/jacoco/jacoco.xml || true
          else
            echo "::error::Arquivo de cobertura JaCoCo n√£o encontrado em target/site/jacoco/jacoco.xml"
            echo "Conte√∫do de target/site/jacoco:"
            ls -la target/site/jacoco || true
            exit 1
          fi
          

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            target
            target/site/jacoco/jacoco.xml
            *.jar

  gates:
    name: Quality Gates
    needs: build_and_test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: .

      - name: Verify downloaded artifacts
        run: |
          if [ -d "target" ]; then
            echo "‚úÖ target encontrado"
            ls -la target
          elif ls ./*.jar 1> /dev/null 2>&1; then
            echo "‚úÖ Jar(s) encontrado(s):"
            ls -la ./*.jar
          else
            echo "::error::Artifact 'build-artifacts' not encontrado ou vazio. Esperado `target` ou `*.jar`."
            ls -la .
            exit 1
          fi

      - name: SonarQube Scan
        if: ${{ inputs.run_gates }}
        uses: SonarSource/sonarqube-scan-action@v6.0.0
        with:
          args: >
            -Dsonar.coverage.jacoco.xmlReportPaths="**/target/site/jacoco/jacoco.xml"
            -Dsonar.branch.name=${{ github.ref_name }}
            ${{ github.ref_name != 'main' && format('-Dsonar.branch.target=main') || '' }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: Debug .scannerwork
        run: |
          echo "Procurando .scannerwork/report-task.txt..."
          find . -name report-task.txt

      - name: Salvar report-task.txt como artifact
        if: ${{ inputs.run_gates && github.ref == 'refs/heads/main' }}
        uses: actions/upload-artifact@v4
        with:
          name: sonar-report-task
          path: .scannerwork/report-task.txt

      - name: Baixar report-task.txt
        if: ${{ inputs.run_gates && github.ref == 'refs/heads/main' }}
        uses: actions/download-artifact@v4
        with:
          name: sonar-report-task
          path: .scannerwork

      - name: Wait for SonarQube Quality Gate
        if: ${{ inputs.run_gates && github.ref == 'refs/heads/main' }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          echo "Conte√∫do de .scannerwork/report-task.txt (se existir):"
          if [ -f ".scannerwork/report-task.txt" ]; then
            cat .scannerwork/report-task.txt
          else
            echo "::warning::Arquivo .scannerwork/report-task.txt n√£o encontrado no diret√≥rio atual"
            ls -la .scannerwork || true
          fi
          set -euo pipefail

          REPORT_FILE=".scannerwork/report-task.txt"
          if [ ! -f "$REPORT_FILE" ]; then
            echo "::error::Arquivo de report do scanner n√£o encontrado: $REPORT_FILE"
            ls -la .
            exit 1
          fi

          CE_TASK_ID=$(grep '^ceTaskId=' "$REPORT_FILE" | cut -d'=' -f2)
          SERVER_URL=$(grep '^serverUrl=' "$REPORT_FILE" | cut -d'=' -f2)

          if [ -z "$CE_TASK_ID" ] || [ -z "$SERVER_URL" ]; then
            echo "::error::N√£o foi poss√≠vel obter ceTaskId ou serverUrl do $REPORT_FILE"
            cat "$REPORT_FILE"
            exit 1
          fi

          echo "Aguardando conclus√£o da task do Sonar (ceTaskId=$CE_TASK_ID)..."

          ANALYSIS_ID=""
          MAX_TRIES=30
          TRY=0
          until [ "$TRY" -ge "$MAX_TRIES" ] || [ -n "$ANALYSIS_ID" ]; do
            TRY=$((TRY+1))
            sleep 10
            JSON=$(curl -s -u "${SONAR_TOKEN}:" "${SERVER_URL}/api/ce/task?id=${CE_TASK_ID}")
            STATUS=$(echo "$JSON" | jq -r '.task.status // empty')
            if [ "$STATUS" = "SUCCESS" ]; then
              ANALYSIS_ID=$(echo "$JSON" | jq -r '.task.analysisId // empty')
              break
            elif [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "CANCELED" ]; then
              echo "::error::Sonar CE task com status $STATUS"
              echo "$JSON"
              exit 1
            else
              echo "Tentativa $TRY/$MAX_TRIES - status: ${STATUS:-PENDING} ..."
            fi
          done

          if [ -z "$ANALYSIS_ID" ]; then
            echo "::error::Timeout aguardando conclus√£o da CE task"
            exit 1
          fi

          echo "CE task conclu√≠da. analysisId=$ANALYSIS_ID"
          echo "Consultando Quality Gate..."

          QG_JSON=$(curl -s -u "${SONAR_TOKEN}:" "${SERVER_URL}/api/qualitygates/project_status?analysisId=${ANALYSIS_ID}")
          QG_STATUS=$(echo "$QG_JSON" | jq -r '.projectStatus.status // empty')

          echo "Quality Gate status: $QG_STATUS"
          echo "$QG_JSON" | jq .

          if [ "$QG_STATUS" != "OK" ]; then
            echo "::error::Quality Gate falhou: $QG_STATUS"
            # opcional: imprimir condi√ß√µes falhadas
            echo "$QG_JSON" | jq -r '.projectStatus.conditions[] | "- \(.metricKey): \(.status) (\(.actualValue) - expected: \(.operator) \(.errorThreshold // .period))"'
            exit 1
          fi

          echo "‚úÖ Quality Gate OK"

  docker-build-and-push:
    name: Build and Push Docker Image
    needs:  build_and_test
    runs-on: ubuntu-latest
    if: inputs.run_docker_build_and_push
    outputs:
      new_image_pushed: ${{ steps.check_tag.outputs.tag_exists == 'false' }}
      image_tag: ${{ needs.build_and_test.outputs.image_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check if image tag already exists on Docker Hub
        id: check_tag
        run: |
          IMAGE_TAG="${{ needs.build_and_test.outputs.image_tag }}"
          IMAGE_NAME="${{ inputs.dockerhub_username }}/${{ inputs.app_name }}"
          
          echo "üîç Verificando se a tag '$IMAGE_TAG' j√° existe no Docker Hub..."
          
          # Verificar se a tag existe usando a API do Docker Hub
          RESPONSE=$(curl -s "https://hub.docker.com/v2/repositories/${IMAGE_NAME}/tags/${IMAGE_TAG}")
          
          if echo "$RESPONSE" | grep -q '"name"'; then
            echo "‚è≠Ô∏è  Tag '$IMAGE_TAG' j√° existe no Docker Hub. Pulando build e push."
            echo "tag_exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Tag '$IMAGE_TAG' n√£o existe. Continuando com build e push."
            echo "tag_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Build Docker image
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          IMAGE_TAG="${{ needs.build_and_test.outputs.image_tag }}"
          echo "üê≥ Construindo imagem Docker com tag: $IMAGE_TAG"
          docker build -t ${{ inputs.app_name }}:$IMAGE_TAG .
          docker tag ${{ inputs.app_name }}:$IMAGE_TAG ${{ inputs.app_name }}:latest

      - name: Login to Docker Hub
        if: steps.check_tag.outputs.tag_exists == 'false'
        uses: docker/login-action@v3
        with:
          username: ${{ inputs.dockerhub_username }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Tag Docker image for Docker Hub
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          IMAGE_TAG="${{ needs.build_and_test.outputs.image_tag }}"
          echo "üè∑Ô∏è  Criando tags para Docker Hub..."
          docker tag ${{ inputs.app_name }}:$IMAGE_TAG ${{ inputs.dockerhub_username }}/${{ inputs.app_name }}:$IMAGE_TAG
          docker tag ${{ inputs.app_name }}:$IMAGE_TAG ${{ inputs.dockerhub_username }}/${{ inputs.app_name }}:latest
          echo "‚úÖ Tags criadas: $IMAGE_TAG e latest"

      - name: Push Docker image to Docker Hub
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          IMAGE_TAG="${{ needs.build_and_test.outputs.image_tag }}"
          echo "üì§ Enviando imagens para Docker Hub..."
          docker push ${{ inputs.dockerhub_username }}/${{ inputs.app_name }}:$IMAGE_TAG
          docker push ${{ inputs.dockerhub_username }}/${{ inputs.app_name }}:latest
          echo "‚úÖ Imagens publicadas:"
          echo "  - ${{ inputs.dockerhub_username }}/${{ inputs.app_name }}:$IMAGE_TAG"
          echo "  - ${{ inputs.dockerhub_username }}/${{ inputs.app_name }}:latest"

  update-deployment-tag:
    name: Update Deployment Tag
    needs: docker-build-and-push
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/main' && inputs.run_update_deployment && needs.docker-build-and-push.outputs.new_image_pushed == 'true' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update deployment image tag
        run: |
          IMAGE_TAG="${{ needs.docker-build-and-push.outputs.image_tag }}"
          IMAGE_NAME="${{ inputs.dockerhub_username }}/${{ inputs.app_name }}"
          DEPLOYMENT_PATH="${{ inputs.deployment_path }}"
          
          echo "üè∑Ô∏è Atualizando tag da imagem para: $IMAGE_TAG"
          echo "üìÅ Arquivo: $DEPLOYMENT_PATH"
          
          if [ ! -f "$DEPLOYMENT_PATH" ]; then
            echo "‚ùå ERRO: Arquivo $DEPLOYMENT_PATH n√£o encontrado"
            exit 1
          fi
          
          sed -i "s|image: ${IMAGE_NAME}:.*|image: ${IMAGE_NAME}:${IMAGE_TAG}|" "$DEPLOYMENT_PATH"
          echo "‚úÖ Tag atualizada:"
          grep "image:" "$DEPLOYMENT_PATH"

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ${{ inputs.deployment_path }}
          git diff --staged --quiet || git commit -m "release: ${{ needs.docker-build-and-push.outputs.image_tag }} [skip ci]"
          git push

  call-cd:
    name: Trigger CD Workflow
    needs: [docker-build-and-push, update-deployment-tag]
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/main' && inputs.run_cd && needs.docker-build-and-push.outputs.new_image_pushed == 'true' }}
    steps:
      - name: Trigger CD workflow
        run: |
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/dispatches \
            -d "{\"event_type\": \"deploy\"}"
